// THIS FILE WAS AUTOGENERATED - ANY EDITS TO THIS WILL BE LOST WHEN IT IS REGENERATED




package sqlc

import (
	"time"
)

type InsertSetStep interface {
	
 	SetString(StringField, string) InsertSetMoreStep
 	
 	SetInt(IntField, int) InsertSetMoreStep
 	
 	SetInt64(Int64Field, int64) InsertSetMoreStep
 	
 	SetTime(TimeField, time.Time) InsertSetMoreStep
 	
}

type UpdateSetStep interface {
	
 	SetString(StringField, string) UpdateSetMoreStep
 	
 	SetInt(IntField, int) UpdateSetMoreStep
 	
 	SetInt64(Int64Field, int64) UpdateSetMoreStep
 	
 	SetTime(TimeField, time.Time) UpdateSetMoreStep
 	
}


func (i *insert) SetString(f StringField, v string) InsertSetMoreStep {
	return i.set(f,v)
}

func (i *insert) SetInt(f IntField, v int) InsertSetMoreStep {
	return i.set(f,v)
}

func (i *insert) SetInt64(f Int64Field, v int64) InsertSetMoreStep {
	return i.set(f,v)
}

func (i *insert) SetTime(f TimeField, v time.Time) InsertSetMoreStep {
	return i.set(f,v)
}



func (u *update) SetString(f StringField, v string) UpdateSetMoreStep {
	return u.set(f,v)
}

func (u *update) SetInt(f IntField, v int) UpdateSetMoreStep {
	return u.set(f,v)
}

func (u *update) SetInt64(f Int64Field, v int64) UpdateSetMoreStep {
	return u.set(f,v)
}

func (u *update) SetTime(f TimeField, v time.Time) UpdateSetMoreStep {
	return u.set(f,v)
}


/////

type Reflectable interface {

	StringField(name string) StringField

	IntField(name string) IntField

	Int64Field(name string) Int64Field

	TimeField(name string) TimeField

}

type Functional interface {

	Avg() Field

	Max() Field

	Min() Field

	Ceil() Field

	Div(_0 interface{}) Field

	Cast(_0 interface{}) Field

	Md5() Field

	Lower() Field

	Hex() Field

}


func (s *selection) StringField(name string) StringField {
	return &stringField{name: name}
}
func (t table) StringField(name string) StringField {
	return &stringField{name: name, selection: t}
}

func (s *selection) IntField(name string) IntField {
	return &intField{name: name}
}
func (t table) IntField(name string) IntField {
	return &intField{name: name, selection: t}
}

func (s *selection) Int64Field(name string) Int64Field {
	return &int64Field{name: name}
}
func (t table) Int64Field(name string) Int64Field {
	return &int64Field{name: name, selection: t}
}

func (s *selection) TimeField(name string) TimeField {
	return &timeField{name: name}
}
func (t table) TimeField(name string) TimeField {
	return &timeField{name: name, selection: t}
}


/////



type stringField struct {
	name string
	selection Selectable
	alias string
	fun FieldFunction
}

type StringField interface {
	TableField
	
	Eq(value string) Condition
	IsEq(value StringField) JoinCondition
	
	Gt(value string) Condition
	IsGt(value StringField) JoinCondition
	
	Ge(value string) Condition
	IsGe(value StringField) JoinCondition
	
	Lt(value string) Condition
	IsLt(value StringField) JoinCondition
	
	Le(value string) Condition
	IsLe(value StringField) JoinCondition
	
}

func (c *stringField) Function() FieldFunction {
	return FieldFunction{
		Name:  c.fun.Name,
		Expr:  c.fun.Expr,
		Args:  c.fun.Args,
		Child: c.fun.Child,
	}
}

func (c *stringField) fct(fun, expr string, args ...interface{}) Field {
	if &c.fun == nil {
		return &stringField{
			name:      c.name,
			selection: c.selection,
			fun:       FieldFunction{Name:fun, Expr:expr, Args: args},
		}
	} else {
		return &stringField{
			name:      c.name,
			selection: c.selection,
			fun:       FieldFunction{
				Name:  fun,
				Expr:  expr, 
				Args:  args,
				Child: &FieldFunction{
					Name:  c.fun.Name,
					Expr:  c.fun.Expr,
					Args:  c.fun.Args,
					Child: c.fun.Child,
				},
			},
		}
	}
}

func (c *stringField) As(alias string) Field {
	return &stringField{
		name: c.name, 
		selection: c.selection,
		alias: alias,
		fun: FieldFunction{
			Name:  c.fun.Name,
			Expr:  c.fun.Expr,
			Args:  c.fun.Args,
			Child: c.fun.Child,
		},
	}
}

func (c *stringField) Alias() string {
	return c.alias
}

func (c *stringField) MaybeAlias() string {
	if c.alias == "" {
		return c.name
	} else {
		return c.alias
	}
}

func (c *stringField) Name() string {
	return c.name
}

func (c *stringField) Parent() Selectable {
	return c.selection
}

// --



func (c *stringField) Eq(pred string) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: EqPredicate}
}

func (c *stringField) IsEq(pred StringField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: EqPredicate}
}



func (c *stringField) Gt(pred string) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: GtPredicate}
}

func (c *stringField) IsGt(pred StringField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: GtPredicate}
}



func (c *stringField) Ge(pred string) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: GePredicate}
}

func (c *stringField) IsGe(pred StringField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: GePredicate}
}



func (c *stringField) Lt(pred string) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: LtPredicate}
}

func (c *stringField) IsLt(pred StringField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: LtPredicate}
}



func (c *stringField) Le(pred string) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: LePredicate}
}

func (c *stringField) IsLe(pred StringField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: LePredicate}
}



// --

func String(s Selectable, name string) StringField {
	return &stringField{name: name, selection: s}
}

//////


func (c *stringField) Avg() Field {	
	return c.fct("Avg", "AVG(%s)")
}

func (c *stringField) Max() Field {	
	return c.fct("Max", "MAX(%s)")
}

func (c *stringField) Min() Field {	
	return c.fct("Min", "MIN(%s)")
}

func (c *stringField) Ceil() Field {	
	return c.fct("Ceil", "CEIL(%s)")
}

func (c *stringField) Div(_0 interface{}) Field {	
	return c.fct("Div", "%s / %v", _0)
}

func (c *stringField) Cast(_0 interface{}) Field {	
	return c.fct("Cast", "CAST(%s AS %s)", _0)
}

func (c *stringField) Md5() Field {	
	return c.fct("Md5", "MD5(%s)")
}

func (c *stringField) Lower() Field {	
	return c.fct("Lower", "LOWER(%s)")
}

func (c *stringField) Hex() Field {	
	return c.fct("Hex", "HEX(%s)")
}




type intField struct {
	name string
	selection Selectable
	alias string
	fun FieldFunction
}

type IntField interface {
	TableField
	
	Eq(value int) Condition
	IsEq(value IntField) JoinCondition
	
	Gt(value int) Condition
	IsGt(value IntField) JoinCondition
	
	Ge(value int) Condition
	IsGe(value IntField) JoinCondition
	
	Lt(value int) Condition
	IsLt(value IntField) JoinCondition
	
	Le(value int) Condition
	IsLe(value IntField) JoinCondition
	
}

func (c *intField) Function() FieldFunction {
	return FieldFunction{
		Name:  c.fun.Name,
		Expr:  c.fun.Expr,
		Args:  c.fun.Args,
		Child: c.fun.Child,
	}
}

func (c *intField) fct(fun, expr string, args ...interface{}) Field {
	if &c.fun == nil {
		return &intField{
			name:      c.name,
			selection: c.selection,
			fun:       FieldFunction{Name:fun, Expr:expr, Args: args},
		}
	} else {
		return &intField{
			name:      c.name,
			selection: c.selection,
			fun:       FieldFunction{
				Name:  fun,
				Expr:  expr, 
				Args:  args,
				Child: &FieldFunction{
					Name:  c.fun.Name,
					Expr:  c.fun.Expr,
					Args:  c.fun.Args,
					Child: c.fun.Child,
				},
			},
		}
	}
}

func (c *intField) As(alias string) Field {
	return &intField{
		name: c.name, 
		selection: c.selection,
		alias: alias,
		fun: FieldFunction{
			Name:  c.fun.Name,
			Expr:  c.fun.Expr,
			Args:  c.fun.Args,
			Child: c.fun.Child,
		},
	}
}

func (c *intField) Alias() string {
	return c.alias
}

func (c *intField) MaybeAlias() string {
	if c.alias == "" {
		return c.name
	} else {
		return c.alias
	}
}

func (c *intField) Name() string {
	return c.name
}

func (c *intField) Parent() Selectable {
	return c.selection
}

// --



func (c *intField) Eq(pred int) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: EqPredicate}
}

func (c *intField) IsEq(pred IntField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: EqPredicate}
}



func (c *intField) Gt(pred int) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: GtPredicate}
}

func (c *intField) IsGt(pred IntField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: GtPredicate}
}



func (c *intField) Ge(pred int) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: GePredicate}
}

func (c *intField) IsGe(pred IntField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: GePredicate}
}



func (c *intField) Lt(pred int) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: LtPredicate}
}

func (c *intField) IsLt(pred IntField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: LtPredicate}
}



func (c *intField) Le(pred int) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: LePredicate}
}

func (c *intField) IsLe(pred IntField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: LePredicate}
}



// --

func Int(s Selectable, name string) IntField {
	return &intField{name: name, selection: s}
}

//////


func (c *intField) Avg() Field {	
	return c.fct("Avg", "AVG(%s)")
}

func (c *intField) Max() Field {	
	return c.fct("Max", "MAX(%s)")
}

func (c *intField) Min() Field {	
	return c.fct("Min", "MIN(%s)")
}

func (c *intField) Ceil() Field {	
	return c.fct("Ceil", "CEIL(%s)")
}

func (c *intField) Div(_0 interface{}) Field {	
	return c.fct("Div", "%s / %v", _0)
}

func (c *intField) Cast(_0 interface{}) Field {	
	return c.fct("Cast", "CAST(%s AS %s)", _0)
}

func (c *intField) Md5() Field {	
	return c.fct("Md5", "MD5(%s)")
}

func (c *intField) Lower() Field {	
	return c.fct("Lower", "LOWER(%s)")
}

func (c *intField) Hex() Field {	
	return c.fct("Hex", "HEX(%s)")
}




type int64Field struct {
	name string
	selection Selectable
	alias string
	fun FieldFunction
}

type Int64Field interface {
	TableField
	
	Eq(value int64) Condition
	IsEq(value Int64Field) JoinCondition
	
	Gt(value int64) Condition
	IsGt(value Int64Field) JoinCondition
	
	Ge(value int64) Condition
	IsGe(value Int64Field) JoinCondition
	
	Lt(value int64) Condition
	IsLt(value Int64Field) JoinCondition
	
	Le(value int64) Condition
	IsLe(value Int64Field) JoinCondition
	
}

func (c *int64Field) Function() FieldFunction {
	return FieldFunction{
		Name:  c.fun.Name,
		Expr:  c.fun.Expr,
		Args:  c.fun.Args,
		Child: c.fun.Child,
	}
}

func (c *int64Field) fct(fun, expr string, args ...interface{}) Field {
	if &c.fun == nil {
		return &int64Field{
			name:      c.name,
			selection: c.selection,
			fun:       FieldFunction{Name:fun, Expr:expr, Args: args},
		}
	} else {
		return &int64Field{
			name:      c.name,
			selection: c.selection,
			fun:       FieldFunction{
				Name:  fun,
				Expr:  expr, 
				Args:  args,
				Child: &FieldFunction{
					Name:  c.fun.Name,
					Expr:  c.fun.Expr,
					Args:  c.fun.Args,
					Child: c.fun.Child,
				},
			},
		}
	}
}

func (c *int64Field) As(alias string) Field {
	return &int64Field{
		name: c.name, 
		selection: c.selection,
		alias: alias,
		fun: FieldFunction{
			Name:  c.fun.Name,
			Expr:  c.fun.Expr,
			Args:  c.fun.Args,
			Child: c.fun.Child,
		},
	}
}

func (c *int64Field) Alias() string {
	return c.alias
}

func (c *int64Field) MaybeAlias() string {
	if c.alias == "" {
		return c.name
	} else {
		return c.alias
	}
}

func (c *int64Field) Name() string {
	return c.name
}

func (c *int64Field) Parent() Selectable {
	return c.selection
}

// --



func (c *int64Field) Eq(pred int64) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: EqPredicate}
}

func (c *int64Field) IsEq(pred Int64Field) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: EqPredicate}
}



func (c *int64Field) Gt(pred int64) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: GtPredicate}
}

func (c *int64Field) IsGt(pred Int64Field) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: GtPredicate}
}



func (c *int64Field) Ge(pred int64) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: GePredicate}
}

func (c *int64Field) IsGe(pred Int64Field) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: GePredicate}
}



func (c *int64Field) Lt(pred int64) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: LtPredicate}
}

func (c *int64Field) IsLt(pred Int64Field) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: LtPredicate}
}



func (c *int64Field) Le(pred int64) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: LePredicate}
}

func (c *int64Field) IsLe(pred Int64Field) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: LePredicate}
}



// --

func Int64(s Selectable, name string) Int64Field {
	return &int64Field{name: name, selection: s}
}

//////


func (c *int64Field) Avg() Field {	
	return c.fct("Avg", "AVG(%s)")
}

func (c *int64Field) Max() Field {	
	return c.fct("Max", "MAX(%s)")
}

func (c *int64Field) Min() Field {	
	return c.fct("Min", "MIN(%s)")
}

func (c *int64Field) Ceil() Field {	
	return c.fct("Ceil", "CEIL(%s)")
}

func (c *int64Field) Div(_0 interface{}) Field {	
	return c.fct("Div", "%s / %v", _0)
}

func (c *int64Field) Cast(_0 interface{}) Field {	
	return c.fct("Cast", "CAST(%s AS %s)", _0)
}

func (c *int64Field) Md5() Field {	
	return c.fct("Md5", "MD5(%s)")
}

func (c *int64Field) Lower() Field {	
	return c.fct("Lower", "LOWER(%s)")
}

func (c *int64Field) Hex() Field {	
	return c.fct("Hex", "HEX(%s)")
}




type timeField struct {
	name string
	selection Selectable
	alias string
	fun FieldFunction
}

type TimeField interface {
	TableField
	
	Eq(value time.Time) Condition
	IsEq(value TimeField) JoinCondition
	
	Gt(value time.Time) Condition
	IsGt(value TimeField) JoinCondition
	
	Ge(value time.Time) Condition
	IsGe(value TimeField) JoinCondition
	
	Lt(value time.Time) Condition
	IsLt(value TimeField) JoinCondition
	
	Le(value time.Time) Condition
	IsLe(value TimeField) JoinCondition
	
}

func (c *timeField) Function() FieldFunction {
	return FieldFunction{
		Name:  c.fun.Name,
		Expr:  c.fun.Expr,
		Args:  c.fun.Args,
		Child: c.fun.Child,
	}
}

func (c *timeField) fct(fun, expr string, args ...interface{}) Field {
	if &c.fun == nil {
		return &timeField{
			name:      c.name,
			selection: c.selection,
			fun:       FieldFunction{Name:fun, Expr:expr, Args: args},
		}
	} else {
		return &timeField{
			name:      c.name,
			selection: c.selection,
			fun:       FieldFunction{
				Name:  fun,
				Expr:  expr, 
				Args:  args,
				Child: &FieldFunction{
					Name:  c.fun.Name,
					Expr:  c.fun.Expr,
					Args:  c.fun.Args,
					Child: c.fun.Child,
				},
			},
		}
	}
}

func (c *timeField) As(alias string) Field {
	return &timeField{
		name: c.name, 
		selection: c.selection,
		alias: alias,
		fun: FieldFunction{
			Name:  c.fun.Name,
			Expr:  c.fun.Expr,
			Args:  c.fun.Args,
			Child: c.fun.Child,
		},
	}
}

func (c *timeField) Alias() string {
	return c.alias
}

func (c *timeField) MaybeAlias() string {
	if c.alias == "" {
		return c.name
	} else {
		return c.alias
	}
}

func (c *timeField) Name() string {
	return c.name
}

func (c *timeField) Parent() Selectable {
	return c.selection
}

// --



func (c *timeField) Eq(pred time.Time) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: EqPredicate}
}

func (c *timeField) IsEq(pred TimeField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: EqPredicate}
}



func (c *timeField) Gt(pred time.Time) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: GtPredicate}
}

func (c *timeField) IsGt(pred TimeField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: GtPredicate}
}



func (c *timeField) Ge(pred time.Time) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: GePredicate}
}

func (c *timeField) IsGe(pred TimeField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: GePredicate}
}



func (c *timeField) Lt(pred time.Time) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: LtPredicate}
}

func (c *timeField) IsLt(pred TimeField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: LtPredicate}
}



func (c *timeField) Le(pred time.Time) Condition {
	return Condition{Binding: FieldBinding{Value: pred, Field: c}, Predicate: LePredicate}
}

func (c *timeField) IsLe(pred TimeField) JoinCondition {
	return JoinCondition{Lhs: c, Rhs: pred, Predicate: LePredicate}
}



// --

func Time(s Selectable, name string) TimeField {
	return &timeField{name: name, selection: s}
}

//////


func (c *timeField) Avg() Field {	
	return c.fct("Avg", "AVG(%s)")
}

func (c *timeField) Max() Field {	
	return c.fct("Max", "MAX(%s)")
}

func (c *timeField) Min() Field {	
	return c.fct("Min", "MIN(%s)")
}

func (c *timeField) Ceil() Field {	
	return c.fct("Ceil", "CEIL(%s)")
}

func (c *timeField) Div(_0 interface{}) Field {	
	return c.fct("Div", "%s / %v", _0)
}

func (c *timeField) Cast(_0 interface{}) Field {	
	return c.fct("Cast", "CAST(%s AS %s)", _0)
}

func (c *timeField) Md5() Field {	
	return c.fct("Md5", "MD5(%s)")
}

func (c *timeField) Lower() Field {	
	return c.fct("Lower", "LOWER(%s)")
}

func (c *timeField) Hex() Field {	
	return c.fct("Hex", "HEX(%s)")
}



